# clean.rb
#
# This file loads each post in a corpus in turn, ensures that it has valid
# encoding, parses any metadata, and saves it as a json file

require 'json'

unless ARGV[0]
  puts "missing corpus argument"
  puts "try: ruby clean.rb abortion"
  exit
end

# for each of the posts in the corpus
Dir.glob("#{ARGV[0]}/*").to_a.each do |file, index|
  puts file

  # remove json files previously generated by this file
  if file.include? "json"
    `rm #{file}`
    next
  end
  content = File.open(file).read

  # reject invalid characters that cause issues during point extraction
  content = content.chars.select(&:valid_encoding?).join

  # parse metadata lines (#key=value)
  meta = Hash[*content.scan(/^#.*=.*$/).map { |e| e.delete('#').split("=") }.flatten]
  meta = meta.inject({}){ |memo,(k,v)| memo[k.to_sym] = v; memo }.merge!(post: file.gsub(/[^0-9]/, ''))

  # remove invalid substrings such as URLs
  content = content
    .gsub(/^#.*=.*$/, "")
    .gsub(/\[[0-9]+\]/, "")
    .gsub(/http\S+|\S{30,}/, "")
    .gsub(/([a-z]{3,}\.)([A-Z][a-z]{3,})/, '\1 \2')
    .gsub(/([a-z]{3,}\.)([0-9]\.)/, '\1 \2')
    .gsub(/\s+/, " ")
    .gsub("[...]", "")
    .gsub("/>", "")
    .gsub(" / ", "")
    .strip

  # output the file as json using the same name, only with a .json extension
  processed_file = meta.merge(content: content)
  File.open("#{file}.json", "w").write(processed_file.to_json)
end
