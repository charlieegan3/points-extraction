This document is also available online at: \\ http://bit.ly/points\_extraction\_maintenance\_manual

\noindent\hrulefill

\noindent This document is intended to describe how the different components may
be adjusted in future work. Some features and potential adjustments are
described using references to key sections of code.

\section{Points Extraction}

Extracting points as part of generating a summary for a debate is
described in the user manual. This however makes use of the
\texttt{analysis\_api} to collect points. This should could be seen as
an example of how one might use the \texttt{points\_api} service. This
section of code in the \texttt{collector.rb} file in the
\texttt{analysis\_api} folder is where points for text are exacted.

\begin{verbatim}
# specify where the points_api is running
uri = URI('http://points_api:4567/')
# create an http client to make the upcoming requests
http = Net::HTTP.new(uri.host, uri.port)
# for each of the posts in the discussion corpus, extract the points.
posts.each_with_index do |post, index|
  # prepare a request object
  # [post text, topics of interest and required point attribute keys]
  query = { text: post["content"], topics: topics, keys: %w(string pattern) }.to_json
  # make the request against the points api
  req = Net::HTTP::Post.new(uri)
  req.body = query
  # parse the response from the points api
  data = JSON.parse(http.request(req).body)
  # write each point in the response to the points file
  data.map { |p| out_file.write("#{p.merge(post).to_json},\n") }
end
\end{verbatim}

This shows that extracting points with the points api is a simple
request/response process. This excerpt from the points\_api shows in
part how requests for points are handled. The input text is split into
sentences (each with a dependency parse) and these are saved in turn to
the neo4j database.

\begin{verbatim}
# save each group of sentences
sentences.each_slice(5).each do |group|
    # Generate a Cypher query and execute it to save them all to the database
    query_string = neo4j_client.generate_create_query_for_sentences(group)
    neo4j_client.execute(query_string)
end
# find all the verbs that match one or more of their frames.
matches = PointsExtraction.matches_for_verbs(neo4j_client, frames, frame_queries)
# upgrade matches to points with extracts, collect points.
points += PointsExtraction.points_for_matches(neo4j_client, matches, data['topics'], data['keys'])
\end{verbatim}

\section{Summary Customization}

It is also likely that the summary content will need to be adjusted. The
key files used in generating summaries are \texttt{summary.rb} and
\texttt{template\_formatted.html.erb} in the summarizer folder.

Summaries are generated by calling \texttt{build}. This section below
shows how this method generates each section of the summary in turn.
Removing one of these lines will stop that section from being generated.

\begin{verbatim}
@counter_points = generate_counter_points; print "."
@related_points = generate_related_points; print "."
@negated_points = generate_negated_points; print "."
@common_points = generate_common_points; print "."
@longer_points = generate_longer_points; print "."
@commonly_discussed_topic_points = generate_commonly_discussed_topic_points; print "."
@multiple_topic_points = generate_multiple_topic_points; print "."
@question_points = generate_question_points; print ".\n"
\end{verbatim}

If a section is removed it must also be removed from the summary
template. Sections in the template look like this and should be removed
if the summary content has been adjusted.

\begin{verbatim}
<p>Points about <strong>multiple topics</strong>:</p>
<% @summary.multiple_topic_points.each do |point| %>
  <blockquote>
    <p><%= Presenter.format(point["String"], @summary.topics) %></p>
  </blockquote>
<% end %>
\end{verbatim}

Summaries can also be customised in other ways. When initializing a
summary with
\texttt{Summary.new(title,\ points,\ topics,\ point\_count)} we can see
that a title (`abortion'), list of points, topics, and a point\_count is
required. Increasing the \texttt{point\_count} will create longer
summaries.

\section{Project Source Listing}

\subsection*{analysis\_api}

\begin{itemize}

\item
  \texttt{Dockerfile}:
\item
  \texttt{clean.rb}:
\item
  \texttt{collector.rb}:
\end{itemize}

\subsection*{corenlp\_server}

\begin{itemize}

\item
  \texttt{Dockerfile}:
\end{itemize}

\subsection*{curator}

\begin{itemize}

\item
  \texttt{Dockerfile}:
\item
  \texttt{main.go}:
\end{itemize}

\subsection*{docker-compose.yml}

\subsection*{docs}

\begin{itemize}

\item
  \texttt{presentation}:
\item
  \texttt{report}:
\end{itemize}

\subsection*{evaluation}

\begin{itemize}

\item
  \texttt{evaluation\_sheet}:
\item
  \texttt{extract\_comparison\ (RESULTS)}:
\item
  \texttt{summary\_comparison\ (RESULTS)}:
\item
  \texttt{extract\_ranking.rb}:
\item
  \texttt{process\_extract\_comparison.rb}:
\item
  \texttt{process\_summary\_comparison.rb}:
\item
  \texttt{r\_analysis/}:
\item
  \texttt{study3\_comments.txt}:
\item
  \texttt{survey/}:
\end{itemize}

\subsection*{points\_api}

\begin{itemize}

\item
  \texttt{Dockerfile}:
\item
  \texttt{Gemfile}:
\item
  \texttt{app.rb}:
\item
  \texttt{frame\_queries}:
\item
  \texttt{groups.json}:
\item
  \texttt{lib}:

  \begin{itemize}

  \item
    \texttt{corenlp\_client.rb}:
  \item
    \texttt{frame.rb}:
  \item
    \texttt{neo4j\_client.rb}:
  \item
    \texttt{node.rb}:
  \item
    \texttt{points\_extraction.rb}:
  \item
    \texttt{relation.rb}:
  \item
    \texttt{utils.rb}:
  \end{itemize}
\item
  \texttt{tasks}:

  \begin{itemize}

  \item
    \texttt{parse\_verb\_net.rb}:
  \end{itemize}
\item
  \texttt{verbs.json}:
\end{itemize}

\subsection*{readme.md}

\subsection*{stock\_summarizers}

\begin{itemize}

\item
  \texttt{summarizer\_topic.py}:
\end{itemize}

\subsection*{summarizer}

\begin{itemize}

\item
  \texttt{Dockerfile}:
\item
  \texttt{Gemfile}:
\item
  \texttt{antonyms.json}:
\item
  \texttt{condense.rb}:
\item
  \texttt{counters.rb}:
\item
  \texttt{curator.rb}:
\item
  \texttt{paragraphizer.rb}:
\item
  \texttt{presenter.rb}:
\item
  \texttt{related.rb}:
\item
  \texttt{render.rb}:
\item
  \texttt{summarizer.rb}:
\item
  \texttt{summary.rb}:
\item
  \texttt{template\_formatted.html.erb}:
\item
  \texttt{utils.rb}:
\end{itemize}

\subsection*{topic\_api}

\begin{itemize}
\item
  \texttt{Dockerfile}:
\item
  \texttt{Gemfile}:
\item
  \texttt{app.rb}:
\end{itemize}

\subsection*{utilities}

\begin{itemize}

\item
  \texttt{plotter}:

  \begin{itemize}
  \item
    \texttt{graph.html}:
  \item
    \texttt{plot.rb}:
  \end{itemize}
\end{itemize}

